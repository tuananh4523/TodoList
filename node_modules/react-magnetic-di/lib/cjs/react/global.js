"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.globalDi = void 0;
exports.runWithDi = runWithDi;
var _constants = require("./constants");
var _utils = require("./utils");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var replacementMap = new Map();
var globalDi = exports.globalDi = {
  getDependencies: function getDependencies(realDeps, targetChild) {
    if (replacementMap.size) {
      for (var i = 0; i < realDeps.length; i++) {
        var replacedInj = (0, _utils.findInjectable)(replacementMap, realDeps[i], targetChild);
        if (replacedInj) realDeps[i] = replacedInj.value;
      }
    }
    return realDeps;
  },
  use: function use(injs) {
    if (replacementMap.size) {
      throw new Error("".concat(_constants.PACKAGE_NAME, " has replacements configured already. ") + "Implicit merging is not supported, so please concatenate injectables. " + "If this is not expected, please file a bug report");
    }
    injs.forEach(function (inj) {
      return (0, _utils.addInjectableToMap)(replacementMap, inj);
    });
  },
  clear: function clear() {
    replacementMap.clear();
  },
  _fromProvider: function _fromProvider(injs) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    injs.forEach(function (inj) {
      if (props.global || _constants.diRegistry.get(inj).global) (0, _utils.addInjectableToMap)(replacementMap, inj);
    });
  },
  _remove: function _remove(injs) {
    injs.forEach(function (inj) {
      return (0, _utils.removeInjectableFromMap)(replacementMap, inj);
    });
  }
};
function runWithDi(thunk, deps) {
  globalDi.use(deps);
  var result;
  try {
    result = thunk();
    return result;
  } finally {
    // autocleanup dependences if either async or sync
    if (result && _typeof(result) === 'object' && typeof result.then === 'function') {
      // dont use finally as it "multiplies" rejected promises
      result.then(globalDi.clear, globalDi.clear);
    } else {
      globalDi.clear();
    }
  }
}