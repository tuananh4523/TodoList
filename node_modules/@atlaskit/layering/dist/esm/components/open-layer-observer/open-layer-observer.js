import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { useContext, useState } from 'react';
import invariant from 'tiny-invariant';
import { OpenLayerObserverContext } from './open-layer-observer-context';
/**
 * Layers that are registered without a namespace are grouped under this fallback namespace.
 */
var noNamespaceSymbol = Symbol('no-namespace');
/**
 * Returns the number of open layers across all namespaces.
 * It calculates the sum of the set sizes in the map, which corresponds to the number of open layers.
 */
function getTotalOpenLayerCount(registry) {
  return Array.from(registry.values()).reduce(function (acc, listeners) {
    return acc + listeners.size;
  }, 0);
}

/**
 * Returns the layer count change listeners set for the namespace.
 * If there are no listeners registered for the namespace yet, it creates a new set
 * and adds it to the registry, then returns the new set.
 */
function getListeners(_ref) {
  var registry = _ref.registry,
    namespace = _ref.namespace;
  // 1. If there are existing listeners for this namespace, return the existing set.
  var existingListeners = registry.get(namespace);
  if (existingListeners) {
    return existingListeners;
  }

  // 2. If there are no existing listeners for this namespace, create a new set for this namespace
  // and add it to the registry, then return the new set.
  var newSet = new Set();
  registry.set(namespace, newSet);
  return newSet;
}

/**
 * Returns an instance of the open layer observer API. It internally keeps track of the number of open layers and
 * exposes methods to get the current count, increment/decrement the count, and subscribe to changes.
 */
function createInternalAPI() {
  /**
   * The layer count change listeners for each namespace.
   */
  var namespaceToChangeListenerRegistry = new Map();

  /**
   * The `onClose` listeners for each namespace.
   * Each layer provides an `onClose` callback. **When the layer is open**, its `onClose`
   * callback is registered in this set.
   *
   * This data structure is also used determine the number of open layers.
   */
  var namespaceToLayerCloseListenerRegistry = new Map();

  /**
   * Calls the appropriate layer count change listeners after the number of open layers has changed.
   */
  function callChangeListeners(_ref2) {
    var namespace = _ref2.namespace,
      newCount = _ref2.newCount;
    // 1. Call listeners registered to the specific namespace
    if (namespace) {
      var listenersForNamespace = namespaceToChangeListenerRegistry.get(namespace);

      // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are
      // iterating over it.
      Array.from(listenersForNamespace !== null && listenersForNamespace !== void 0 ? listenersForNamespace : []).forEach(function (listener) {
        return listener({
          count: newCount
        });
      });
    }

    // 2. Call listeners registered without a specific namespace
    var noNamespaceListeners = namespaceToChangeListenerRegistry.get(noNamespaceSymbol);

    // Return early if no listeners
    if (!noNamespaceListeners) {
      return;
    }

    // For the listeners without a specific namespace, we need to provide the sum of all namespace counts
    // as the callback `count` arg.
    var totalCount = getTotalOpenLayerCount(namespaceToLayerCloseListenerRegistry);
    Array.from(noNamespaceListeners).forEach(function (listener) {
      return listener({
        count: totalCount
      });
    });
  }

  /**
   * Returns the current count of open layers.
   *
   * If a namespace is provided, the count for that namespace is returned.
   * Otherwise, the sum of all namespace counts is returned.
   */
  function getCount() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      namespace = _ref3.namespace;
    if (namespace) {
      var _namespaceToLayerClos, _namespaceToLayerClos2;
      return (_namespaceToLayerClos = (_namespaceToLayerClos2 = namespaceToLayerCloseListenerRegistry.get(namespace)) === null || _namespaceToLayerClos2 === void 0 ? void 0 : _namespaceToLayerClos2.size) !== null && _namespaceToLayerClos !== void 0 ? _namespaceToLayerClos : 0;
    }

    // A specific namespace was not requested, so we return the sum across all namespaces.
    return getTotalOpenLayerCount(namespaceToLayerCloseListenerRegistry);
  }

  /**
   * Adds a listener that will be called when the number of open layers changes.
   *
   * @returns a cleanup function to unsubscribe, which should be called when the component unmounts.
   */
  function onChange(listener) {
    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      providedNamespace = _ref4.namespace;
    /**
     * We are wrapping the passed listener in a function to ensure that each call to `onChange` creates a unique
     * function reference. This is to handle scenarios where the same function is provided to several different `onChange`
     * calls - we want to ensure that each call to `unsubscribe` only removes the specific listener registration that was added.
     */
    function wrapped() {
      listener.apply(void 0, arguments);
    }
    var namespace = providedNamespace !== null && providedNamespace !== void 0 ? providedNamespace : noNamespaceSymbol;
    var listenersForNamespace = getListeners({
      namespace: namespace,
      registry: namespaceToChangeListenerRegistry
    });
    listenersForNamespace.add(wrapped);
    return function unsubscribe() {
      listenersForNamespace.delete(wrapped);

      // If there are no listeners for this namespace, remove the registry entry.
      if (listenersForNamespace.size === 0) {
        namespaceToChangeListenerRegistry.delete(namespace);
      }
    };
  }

  /**
   * Adds a listener to the registry that tells the observer how to close the layer component.
   * The listener should only be added if the layer is open. This is handled by `useNotifyOpenLayerObserver`.
   *
   * All close listeners will be called by the observer when `closeLayers` is called.
   *
   * @returns a cleanup function to unsubscribe, which should be called when the component unmounts.
   */
  function onClose(listener, _ref5) {
    var providedNamespace = _ref5.namespace;
    /**
     * We are wrapping the passed listener in a function to ensure that each call to `onClose` creates a unique
     * function reference. This is to handle scenarios where the same function is provided to several different `onClose`
     * calls - we want to ensure that each call to `unsubscribe` only removes the specific listener registration that was added.
     */
    function wrapped() {
      listener();
    }
    var namespace = providedNamespace !== null && providedNamespace !== void 0 ? providedNamespace : noNamespaceSymbol;
    var listenersForNamespace = getListeners({
      namespace: namespace,
      registry: namespaceToLayerCloseListenerRegistry
    });
    listenersForNamespace.add(wrapped);
    callChangeListeners({
      namespace: providedNamespace,
      newCount: listenersForNamespace.size
    });
    return function unsubscribe() {
      listenersForNamespace.delete(wrapped);
      callChangeListeners({
        namespace: providedNamespace,
        newCount: listenersForNamespace.size
      });

      // If there are no listeners for this namespace, remove the registry entry.
      if (listenersForNamespace.size === 0) {
        namespaceToLayerCloseListenerRegistry.delete(namespace);
      }
    };
  }

  /**
   * Closes all open layers registered across all namespaces.
   */
  function closeLayers() {
    // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are
    // iterating over it.
    Array.from(namespaceToLayerCloseListenerRegistry.values()).forEach(function (listeners) {
      Array.from(listeners).forEach(function (listener) {
        return listener();
      });
    });
  }
  var internalAPI = {
    getCount: getCount,
    onChange: onChange,
    onClose: onClose,
    closeLayers: closeLayers
  };
  return internalAPI;
}

/**
 * Context provider for observing the number of __open__ layering components (e.g. popups, dropdown menus) under the observer.
 * It uses a stable object to keep track of the number of open layered components - which means the observer will not re-render
 * when the number of layers changes.
 *
 * There should only be one `OpenLayerObserver` in the application. If there are more, the component will throw an error.
 * To track the number of layers in a section of the application, use the `OpenLayerObserverNamespaceProvider` to create a new
 * namespace to group layers.
 *
 * It is intended for use with the `useOpenLayerObserver` hook.
 */
export function OpenLayerObserver(_ref6) {
  var children = _ref6.children;
  // Using state to ensure a stable reference to a single instance.
  var _useState = useState(function () {
      return createInternalAPI();
    }),
    _useState2 = _slicedToArray(_useState, 1),
    internalAPI = _useState2[0];
  var parentContext = useContext(OpenLayerObserverContext);

  // We don't expect a parent context. If there is one, that means this component is nested within another `OpenLayerObserver`
  // - which we don't support.
  invariant(parentContext === null, '`OpenLayerObserver` cannot be nested within another `OpenLayerObserver`.');
  return /*#__PURE__*/React.createElement(OpenLayerObserverContext.Provider, {
    value: internalAPI
  }, children);
}